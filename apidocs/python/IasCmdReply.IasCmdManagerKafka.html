<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Python: module IasCmdReply.IasCmdManagerKafka</title>
</head><body>

<table class="heading">
<tr class="heading-text decor">
<td class="title">&nbsp;<br><strong class="title"><a href="IasCmdReply.html" class="white">IasCmdReply</a>.IasCmdManagerKafka</strong></td>
<td class="extra"><a href=".">index</a><br><a href="file:/home/fedora/IasRoot/lib/python3.12/site-packages/IasCmdReply/IasCmdManagerKafka.py">/home/fedora/IasRoot/lib/python3.12/site-packages/IasCmdReply/IasCmdManagerKafka.py</a></td></tr></table>
    <p></p>
<p>
<table class="section">
<tr class="decor pkg-content-decor heading-text">
<td class="section-title" colspan=3>&nbsp;<br><strong class="bigsection">Modules</strong></td></tr>
    
<tr><td class="decor pkg-content-decor"><span class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></td><td>&nbsp;</td>
<td class="singlecolumn"><table><tr><td class="multicolumn"><a href="time.html">time</a><br>
</td><td class="multicolumn"></td><td class="multicolumn"></td><td class="multicolumn"></td></tr></table></td></tr></table><p>
<table class="section">
<tr class="decor index-decor heading-text">
<td class="section-title" colspan=3>&nbsp;<br><strong class="bigsection">Classes</strong></td></tr>
    
<tr><td class="decor index-decor"><span class="code">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></td><td>&nbsp;</td>
<td class="singlecolumn"><dl>
<dt class="heading-text"><a href="IasKafkaUtils.IasKafkaConsumer.html#IasLogListener">IasKafkaUtils.IasKafkaConsumer.IasLogListener</a>(<a href="builtins.html#object">builtins.object</a>)
</dt><dd>
<dl>
<dt class="heading-text"><a href="IasCmdReply.IasCmdManagerKafka.html#KafkaLogListener">KafkaLogListener</a>
</dt></dl>
</dd>
<dt class="heading-text"><a href="builtins.html#object">builtins.object</a>
</dt><dd>
<dl>
<dt class="heading-text"><a href="IasCmdReply.IasCmdManagerKafka.html#IasCommandListener">IasCommandListener</a>
</dt><dt class="heading-text">cimpl.Producer
</dt></dl>
</dd>
<dt class="heading-text"><a href="threading.html#Thread">threading.Thread</a>(<a href="builtins.html#object">builtins.object</a>)
</dt><dd>
<dl>
<dt class="heading-text"><a href="IasCmdReply.IasCmdManagerKafka.html#IasCmdManagerKafka">IasCmdManagerKafka</a>
</dt></dl>
</dd>
</dl>
 <p>
<table class="section">
<tr class="decor title-decor heading-text">
<td class="section-title" colspan=3>&nbsp;<br><a name="IasCmdManagerKafka">class <strong>IasCmdManagerKafka</strong></a>(<a href="threading.html#Thread">threading.Thread</a>)</td></tr>
    
<tr><td class="decor title-decor" rowspan=2><span class="code">&nbsp;&nbsp;&nbsp;</span></td>
<td class="decor title-decor" colspan=2><span class="code"><a href="#IasCmdManagerKafka">IasCmdManagerKafka</a>(full_run_id,&nbsp;listener:&nbsp;IasCmdReply.<a href="#IasCmdManagerKafka">IasCmdManagerKafka</a>.<a href="#IasCommandListener">IasCommandListener</a>,&nbsp;kbrokers='localhost:9092',&nbsp;replyProducer:&nbsp;cimpl.<a href="#Producer">Producer</a>&nbsp;|&nbsp;None&nbsp;=&nbsp;None,&nbsp;kclient_id='IasCmdReply.IasCmdManagerKafka2025-01-10T15:08:17.432',&nbsp;kgroup_id='IasCmdReply.IasCmdManagerKafka2025-01-10T15:08:17.432')<br>
&nbsp;<br>
This&nbsp;is&nbsp;the&nbsp;python&nbsp;equivalent&nbsp;of&nbsp;the&nbsp;java&nbsp;CommandManagerKafkaIMpl&nbsp;<br>
but&nbsp;with&nbsp;rduced&nbsp;functionalities&nbsp;as&nbsp;up&nbsp;to&nbsp;now&nbsp;there&nbsp;are&nbsp;no&nbsp;python&nbsp;clients&nbsp;that&nbsp;get&nbsp;comamnds<br>
and&nbsp;send&nbsp;replies.<br>
&nbsp;<br>
This&nbsp;class&nbsp;is&nbsp;the&nbsp;counter&nbsp;part&nbsp;of&nbsp;IasCommandsSender:<br>
&nbsp;-&nbsp;&nbsp;gets&nbsp;commands&nbsp;from&nbsp;the&nbsp;kafka&nbsp;command&nbsp;topic,&nbsp;<br>
&nbsp;-&nbsp;&nbsp;forwards&nbsp;them&nbsp;to&nbsp;the&nbsp;listener&nbsp;for&nbsp;precessing<br>
&nbsp;-&nbsp;&nbsp;sends&nbsp;replies&nbsp;to&nbsp;the&nbsp;kafka&nbsp;reply&nbsp;topic<br>&nbsp;</span></td></tr>
<tr><td>&nbsp;</td>
<td class="singlecolumn"><dl><dt>Method resolution order:</dt>
<dd><a href="IasCmdReply.IasCmdManagerKafka.html#IasCmdManagerKafka">IasCmdManagerKafka</a></dd>
<dd><a href="threading.html#Thread">threading.Thread</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="IasCmdManagerKafka-__init__"><strong>__init__</strong></a>(self, full_run_id, listener: IasCmdReply.IasCmdManagerKafka.IasCommandListener, kbrokers='localhost:9092', replyProducer: cimpl.Producer | None = None, kclient_id='IasCmdReply.IasCmdManagerKafka2025-01-10T15:08:17.432', kgroup_id='IasCmdReply.IasCmdManagerKafka2025-01-10T15:08:17.432')</dt><dd><span class="code">Constructor<br>
&nbsp;<br>
Params:<br>
&nbsp;&nbsp;&nbsp;&nbsp;full_run_id:&nbsp;the&nbsp;full&nbsp;runing&nbsp;ID&nbsp;of&nbsp;the&nbsp;process<br>
&nbsp;&nbsp;&nbsp;&nbsp;listener:&nbsp;the&nbsp;listener&nbsp;of&nbsp;commands<br>
&nbsp;&nbsp;&nbsp;&nbsp;replyProducer&nbsp;the&nbsp;producer&nbsp;of&nbsp;replies,&nbsp;if&nbsp;None&nbsp;a&nbsp;new&nbsp;one&nbsp;is&nbsp;built<br>
&nbsp;&nbsp;&nbsp;&nbsp;kbrokers&nbsp;Kafka&nbsp;brokers<br>
&nbsp;&nbsp;&nbsp;&nbsp;kclient_id&nbsp;The&nbsp;ID&nbsp;of&nbsp;the&nbsp;Kafka&nbsp;client<br>
&nbsp;&nbsp;&nbsp;&nbsp;kgroup_id&nbsp;The&nbsp;id&nbsp;of&nbsp;the&nbsp;Kafka&nbsp;group</span></dd></dl>

<dl><dt><a name="IasCmdManagerKafka-close"><strong>close</strong></a>(self)</dt><dd><span class="code">Stop&nbsp;getting&nbsp;commands</span></dd></dl>

<dl><dt><a name="IasCmdManagerKafka-run"><strong>run</strong></a>(self)</dt><dd><span class="code">The&nbsp;method&nbsp;executed&nbsp;by&nbsp;the&nbsp;tread&nbsp;that&nbsp;sends&nbsp;commands&nbsp;to&nbsp;the&nbsp;lsitener<br>
and&nbsp;pushes&nbsp;replies&nbsp;in&nbsp;the&nbsp;topic</span></dd></dl>

<dl><dt><a name="IasCmdManagerKafka-start"><strong>start</strong></a>(self)</dt><dd><span class="code">Start&nbsp;getting&nbsp;commands</span></dd></dl>

<hr>
Methods inherited from <a href="threading.html#Thread">threading.Thread</a>:<br>
<dl><dt><a name="IasCmdManagerKafka-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><span class="code">Return&nbsp;repr(self).</span></dd></dl>

<dl><dt><a name="IasCmdManagerKafka-getName"><strong>getName</strong></a>(self)</dt><dd><span class="code">Return&nbsp;a&nbsp;string&nbsp;used&nbsp;for&nbsp;identification&nbsp;purposes&nbsp;only.<br>
&nbsp;<br>
This&nbsp;method&nbsp;is&nbsp;deprecated,&nbsp;use&nbsp;the&nbsp;name&nbsp;attribute&nbsp;instead.</span></dd></dl>

<dl><dt><a name="IasCmdManagerKafka-isDaemon"><strong>isDaemon</strong></a>(self)</dt><dd><span class="code">Return&nbsp;whether&nbsp;this&nbsp;thread&nbsp;is&nbsp;a&nbsp;daemon.<br>
&nbsp;<br>
This&nbsp;method&nbsp;is&nbsp;deprecated,&nbsp;use&nbsp;the&nbsp;daemon&nbsp;attribute&nbsp;instead.</span></dd></dl>

<dl><dt><a name="IasCmdManagerKafka-is_alive"><strong>is_alive</strong></a>(self)</dt><dd><span class="code">Return&nbsp;whether&nbsp;the&nbsp;thread&nbsp;is&nbsp;alive.<br>
&nbsp;<br>
This&nbsp;method&nbsp;returns&nbsp;True&nbsp;just&nbsp;before&nbsp;the&nbsp;<a href="#IasCmdManagerKafka-run">run</a>()&nbsp;method&nbsp;starts&nbsp;until&nbsp;just<br>
after&nbsp;the&nbsp;<a href="#IasCmdManagerKafka-run">run</a>()&nbsp;method&nbsp;terminates.&nbsp;See&nbsp;also&nbsp;the&nbsp;module&nbsp;function<br>
enumerate().</span></dd></dl>

<dl><dt><a name="IasCmdManagerKafka-join"><strong>join</strong></a>(self, timeout=None)</dt><dd><span class="code">Wait&nbsp;until&nbsp;the&nbsp;thread&nbsp;terminates.<br>
&nbsp;<br>
This&nbsp;blocks&nbsp;the&nbsp;calling&nbsp;thread&nbsp;until&nbsp;the&nbsp;thread&nbsp;whose&nbsp;<a href="#IasCmdManagerKafka-join">join</a>()&nbsp;method&nbsp;is<br>
called&nbsp;terminates&nbsp;--&nbsp;either&nbsp;normally&nbsp;or&nbsp;through&nbsp;an&nbsp;unhandled&nbsp;exception<br>
or&nbsp;until&nbsp;the&nbsp;optional&nbsp;timeout&nbsp;occurs.<br>
&nbsp;<br>
When&nbsp;the&nbsp;timeout&nbsp;argument&nbsp;is&nbsp;present&nbsp;and&nbsp;not&nbsp;None,&nbsp;it&nbsp;should&nbsp;be&nbsp;a<br>
floating-point&nbsp;number&nbsp;specifying&nbsp;a&nbsp;timeout&nbsp;for&nbsp;the&nbsp;operation&nbsp;in&nbsp;seconds<br>
(or&nbsp;fractions&nbsp;thereof).&nbsp;As&nbsp;<a href="#IasCmdManagerKafka-join">join</a>()&nbsp;always&nbsp;returns&nbsp;None,&nbsp;you&nbsp;must&nbsp;call<br>
<a href="#IasCmdManagerKafka-is_alive">is_alive</a>()&nbsp;after&nbsp;<a href="#IasCmdManagerKafka-join">join</a>()&nbsp;to&nbsp;decide&nbsp;whether&nbsp;a&nbsp;timeout&nbsp;happened&nbsp;--&nbsp;if&nbsp;the<br>
thread&nbsp;is&nbsp;still&nbsp;alive,&nbsp;the&nbsp;<a href="#IasCmdManagerKafka-join">join</a>()&nbsp;call&nbsp;timed&nbsp;out.<br>
&nbsp;<br>
When&nbsp;the&nbsp;timeout&nbsp;argument&nbsp;is&nbsp;not&nbsp;present&nbsp;or&nbsp;None,&nbsp;the&nbsp;operation&nbsp;will<br>
block&nbsp;until&nbsp;the&nbsp;thread&nbsp;terminates.<br>
&nbsp;<br>
A&nbsp;thread&nbsp;can&nbsp;be&nbsp;<a href="#IasCmdManagerKafka-join">join</a>()ed&nbsp;many&nbsp;times.<br>
&nbsp;<br>
<a href="#IasCmdManagerKafka-join">join</a>()&nbsp;raises&nbsp;a&nbsp;RuntimeError&nbsp;if&nbsp;an&nbsp;attempt&nbsp;is&nbsp;made&nbsp;to&nbsp;join&nbsp;the&nbsp;current<br>
thread&nbsp;as&nbsp;that&nbsp;would&nbsp;cause&nbsp;a&nbsp;deadlock.&nbsp;It&nbsp;is&nbsp;also&nbsp;an&nbsp;error&nbsp;to&nbsp;<a href="#IasCmdManagerKafka-join">join</a>()&nbsp;a<br>
thread&nbsp;before&nbsp;it&nbsp;has&nbsp;been&nbsp;started&nbsp;and&nbsp;attempts&nbsp;to&nbsp;do&nbsp;so&nbsp;raises&nbsp;the&nbsp;same<br>
exception.</span></dd></dl>

<dl><dt><a name="IasCmdManagerKafka-setDaemon"><strong>setDaemon</strong></a>(self, daemonic)</dt><dd><span class="code">Set&nbsp;whether&nbsp;this&nbsp;thread&nbsp;is&nbsp;a&nbsp;daemon.<br>
&nbsp;<br>
This&nbsp;method&nbsp;is&nbsp;deprecated,&nbsp;use&nbsp;the&nbsp;.daemon&nbsp;property&nbsp;instead.</span></dd></dl>

<dl><dt><a name="IasCmdManagerKafka-setName"><strong>setName</strong></a>(self, name)</dt><dd><span class="code">Set&nbsp;the&nbsp;name&nbsp;string&nbsp;for&nbsp;this&nbsp;thread.<br>
&nbsp;<br>
This&nbsp;method&nbsp;is&nbsp;deprecated,&nbsp;use&nbsp;the&nbsp;name&nbsp;attribute&nbsp;instead.</span></dd></dl>

<hr>
Readonly properties inherited from <a href="threading.html#Thread">threading.Thread</a>:<br>
<dl><dt><strong>ident</strong></dt>
<dd><span class="code">Thread&nbsp;identifier&nbsp;of&nbsp;this&nbsp;thread&nbsp;or&nbsp;None&nbsp;if&nbsp;it&nbsp;has&nbsp;not&nbsp;been&nbsp;started.<br>
&nbsp;<br>
This&nbsp;is&nbsp;a&nbsp;nonzero&nbsp;integer.&nbsp;See&nbsp;the&nbsp;get_ident()&nbsp;function.&nbsp;Thread<br>
identifiers&nbsp;may&nbsp;be&nbsp;recycled&nbsp;when&nbsp;a&nbsp;thread&nbsp;exits&nbsp;and&nbsp;another&nbsp;thread&nbsp;is<br>
created.&nbsp;The&nbsp;identifier&nbsp;is&nbsp;available&nbsp;even&nbsp;after&nbsp;the&nbsp;thread&nbsp;has&nbsp;exited.</span></dd>
</dl>
<dl><dt><strong>native_id</strong></dt>
<dd><span class="code">Native&nbsp;integral&nbsp;thread&nbsp;ID&nbsp;of&nbsp;this&nbsp;thread,&nbsp;or&nbsp;None&nbsp;if&nbsp;it&nbsp;has&nbsp;not&nbsp;been&nbsp;started.<br>
&nbsp;<br>
This&nbsp;is&nbsp;a&nbsp;non-negative&nbsp;integer.&nbsp;See&nbsp;the&nbsp;get_native_id()&nbsp;function.<br>
This&nbsp;represents&nbsp;the&nbsp;Thread&nbsp;ID&nbsp;as&nbsp;reported&nbsp;by&nbsp;the&nbsp;kernel.</span></dd>
</dl>
<hr>
Data descriptors inherited from <a href="threading.html#Thread">threading.Thread</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><span class="code">dictionary&nbsp;for&nbsp;instance&nbsp;variables</span></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><span class="code">list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object</span></dd>
</dl>
<dl><dt><strong>daemon</strong></dt>
<dd><span class="code">A&nbsp;boolean&nbsp;value&nbsp;indicating&nbsp;whether&nbsp;this&nbsp;thread&nbsp;is&nbsp;a&nbsp;daemon&nbsp;thread.<br>
&nbsp;<br>
This&nbsp;must&nbsp;be&nbsp;set&nbsp;before&nbsp;start()&nbsp;is&nbsp;called,&nbsp;otherwise&nbsp;RuntimeError&nbsp;is<br>
raised.&nbsp;Its&nbsp;initial&nbsp;value&nbsp;is&nbsp;inherited&nbsp;from&nbsp;the&nbsp;creating&nbsp;thread;&nbsp;the<br>
main&nbsp;thread&nbsp;is&nbsp;not&nbsp;a&nbsp;daemon&nbsp;thread&nbsp;and&nbsp;therefore&nbsp;all&nbsp;threads&nbsp;created&nbsp;in<br>
the&nbsp;main&nbsp;thread&nbsp;default&nbsp;to&nbsp;daemon&nbsp;=&nbsp;False.<br>
&nbsp;<br>
The&nbsp;entire&nbsp;Python&nbsp;program&nbsp;exits&nbsp;when&nbsp;only&nbsp;daemon&nbsp;threads&nbsp;are&nbsp;left.</span></dd>
</dl>
<dl><dt><strong>name</strong></dt>
<dd><span class="code">A&nbsp;string&nbsp;used&nbsp;for&nbsp;identification&nbsp;purposes&nbsp;only.<br>
&nbsp;<br>
It&nbsp;has&nbsp;no&nbsp;semantics.&nbsp;Multiple&nbsp;threads&nbsp;may&nbsp;be&nbsp;given&nbsp;the&nbsp;same&nbsp;name.&nbsp;The<br>
initial&nbsp;name&nbsp;is&nbsp;set&nbsp;by&nbsp;the&nbsp;constructor.</span></dd>
</dl>
</td></tr></table> <p>
<table class="section">
<tr class="decor title-decor heading-text">
<td class="section-title" colspan=3>&nbsp;<br><a name="IasCommandListener">class <strong>IasCommandListener</strong></a>(<a href="builtins.html#object">builtins.object</a>)</td></tr>
    
<tr><td class="decor title-decor" rowspan=2><span class="code">&nbsp;&nbsp;&nbsp;</span></td>
<td class="decor title-decor" colspan=2><span class="code">The&nbsp;listener&nbsp;of&nbsp;commands&nbsp;read&nbsp;from&nbsp;IAS&nbsp;cmd&nbsp;topic<br>&nbsp;</span></td></tr>
<tr><td>&nbsp;</td>
<td class="singlecolumn">Methods defined here:<br>
<dl><dt><a name="IasCommandListener-cmdReceived"><strong>cmdReceived</strong></a>(self, cmd: IasCmdReply.IasCommand.IasCommand) -&gt; IasCmdReply.IasCmdExitStatus.IasCmdExitStatus</dt><dd><span class="code">The&nbsp;callback&nbsp;to&nbsp;notify&nbsp;of&nbsp;a&nbsp;new&nbsp;new&nbsp;command&nbsp;to&nbsp;process<br>
&nbsp;<br>
The&nbsp;implementation&nbsp;must&nbsp;override&nbsp;this&nbsp;method<br>
&nbsp;<br>
Args:<br>
&nbsp;&nbsp;&nbsp;cmd&nbsp;received&nbsp;from&nbsp;th&nbsp;ekafka&nbsp;topic<br>
Returns:<br>
&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;exit&nbsp;code&nbsp;afetr&nbsp;processing&nbsp;the&nbsp;command&nbsp;to&nbsp;be&nbsp;set&nbsp;in&nbsp;the&nbsp;reply</span></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><span class="code">dictionary&nbsp;for&nbsp;instance&nbsp;variables</span></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><span class="code">list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object</span></dd>
</dl>
</td></tr></table> <p>
<table class="section">
<tr class="decor title-decor heading-text">
<td class="section-title" colspan=3>&nbsp;<br><a name="KafkaLogListener">class <strong>KafkaLogListener</strong></a>(<a href="IasKafkaUtils.IasKafkaConsumer.html#IasLogListener">IasKafkaUtils.IasKafkaConsumer.IasLogListener</a>)</td></tr>
    
<tr><td class="decor title-decor" rowspan=2><span class="code">&nbsp;&nbsp;&nbsp;</span></td>
<td class="decor title-decor" colspan=2><span class="code"><a href="#KafkaLogListener">KafkaLogListener</a>(logs:&nbsp;queue.Queue,&nbsp;full_run_id:&nbsp;str)<br>
&nbsp;<br>
The&nbsp;listener&nbsp;of&nbsp;comands&nbsp;from&nbsp;the&nbsp;kafka&nbsp;topic<br>
&nbsp;<br>
The&nbsp;listener&nbsp;discards&nbsp;the&nbsp;logs&nbsp;that&nbsp;are&nbsp;not&nbsp;for&nbsp;this&nbsp;process&nbsp;(identified<br>
by&nbsp;the&nbsp;full&nbsp;running&nbsp;ID).<br>
It&nbsp;stores&nbsp;the&nbsp;accpted&nbsp;logs&nbsp;in&nbsp;the&nbsp;queue&nbsp;together&nbsp;with&nbsp;the&nbsp;timestamp.<br>
The&nbsp;logs&nbsp;will&nbsp;be&nbsp;fetched&nbsp;and&nbsp;processed&nbsp;by&nbsp;the&nbsp;tread&nbsp;of&nbsp;the&nbsp;IasCommandManagerKafka&nbsp;<a href="builtins.html#object">object</a><br>&nbsp;</span></td></tr>
<tr><td>&nbsp;</td>
<td class="singlecolumn"><dl><dt>Method resolution order:</dt>
<dd><a href="IasCmdReply.IasCmdManagerKafka.html#KafkaLogListener">KafkaLogListener</a></dd>
<dd><a href="IasKafkaUtils.IasKafkaConsumer.html#IasLogListener">IasKafkaUtils.IasKafkaConsumer.IasLogListener</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="KafkaLogListener-__init__"><strong>__init__</strong></a>(self, logs: queue.Queue, full_run_id: str)</dt><dd><span class="code">Constructor<br>
&nbsp;<br>
Params:<br>
&nbsp;&nbsp;&nbsp;&nbsp;logs:&nbsp;The&nbsp;queue&nbsp;to&nbsp;store&nbsp;IasCommands&nbsp;into<br>
&nbsp;&nbsp;&nbsp;&nbsp;full_run_id:&nbsp;the&nbsp;full&nbsp;runing&nbsp;ID&nbsp;of&nbsp;the&nbsp;process</span></dd></dl>

<dl><dt><a name="KafkaLogListener-iasLogReceived"><strong>iasLogReceived</strong></a>(self, log: str) -&gt; None</dt><dd><span class="code">The&nbsp;callback&nbsp;to&nbsp;notify&nbsp;new&nbsp;IasValues<br>
received&nbsp;from&nbsp;the&nbsp;BSDB<br>
&nbsp;<br>
The&nbsp;implementation&nbsp;must&nbsp;override&nbsp;this&nbsp;method</span></dd></dl>

<hr>
Data descriptors inherited from <a href="IasKafkaUtils.IasKafkaConsumer.html#IasLogListener">IasKafkaUtils.IasKafkaConsumer.IasLogListener</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><span class="code">dictionary&nbsp;for&nbsp;instance&nbsp;variables</span></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><span class="code">list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object</span></dd>
</dl>
</td></tr></table> <p>
<table class="section">
<tr class="decor title-decor heading-text">
<td class="section-title" colspan=3>&nbsp;<br><a name="Producer">class <strong>Producer</strong></a>(<a href="builtins.html#object">builtins.object</a>)</td></tr>
    
<tr><td class="decor title-decor" rowspan=2><span class="code">&nbsp;&nbsp;&nbsp;</span></td>
<td class="decor title-decor" colspan=2><span class="code">Asynchronous&nbsp;Kafka&nbsp;<a href="#Producer">Producer</a><br>
&nbsp;<br>
..&nbsp;py:function::&nbsp;<a href="#Producer">Producer</a>(config)<br>
&nbsp;<br>
&nbsp;&nbsp;:param&nbsp;dict&nbsp;config:&nbsp;Configuration&nbsp;properties.&nbsp;At&nbsp;a&nbsp;minimum&nbsp;``bootstrap.servers``&nbsp;**should**&nbsp;be&nbsp;set<br>
&nbsp;<br>
&nbsp;&nbsp;Create&nbsp;a&nbsp;new&nbsp;<a href="#Producer">Producer</a>&nbsp;instance&nbsp;using&nbsp;the&nbsp;provided&nbsp;configuration&nbsp;dict.<br>
&nbsp;<br>
&nbsp;<br>
..&nbsp;py:function::&nbsp;<a href="#Producer-__len__">__len__</a>(self)<br>
&nbsp;<br>
&nbsp;&nbsp;<a href="#Producer">Producer</a>&nbsp;implements&nbsp;__len__&nbsp;that&nbsp;can&nbsp;be&nbsp;used&nbsp;as&nbsp;len(producer)&nbsp;to&nbsp;obtain&nbsp;number&nbsp;of&nbsp;messages&nbsp;waiting.<br>
&nbsp;&nbsp;:returns:&nbsp;Number&nbsp;of&nbsp;messages&nbsp;and&nbsp;Kafka&nbsp;protocol&nbsp;requests&nbsp;waiting&nbsp;to&nbsp;be&nbsp;delivered&nbsp;to&nbsp;broker.<br>
&nbsp;&nbsp;:rtype:&nbsp;int<br>&nbsp;</span></td></tr>
<tr><td>&nbsp;</td>
<td class="singlecolumn">Methods defined here:<br>
<dl><dt><a name="Producer-__bool__"><strong>__bool__</strong></a>(self, /)</dt><dd><span class="code">True&nbsp;if&nbsp;self&nbsp;else&nbsp;False</span></dd></dl>

<dl><dt><a name="Producer-__init__"><strong>__init__</strong></a>(self, /, *args, **kwargs)</dt><dd><span class="code">Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</span></dd></dl>

<dl><dt><a name="Producer-__len__"><strong>__len__</strong></a>(self, /)</dt><dd><span class="code">Return&nbsp;len(self).</span></dd></dl>

<dl><dt><a name="Producer-abort_transaction"><strong>abort_transaction</strong></a>(...)</dt><dd><span class="code">..&nbsp;py:function::&nbsp;<a href="#Producer-abort_transaction">abort_transaction</a>([timeout])<br>
&nbsp;<br>
Aborts&nbsp;the&nbsp;current&nbsp;transaction.<br>
This&nbsp;function&nbsp;should&nbsp;also&nbsp;be&nbsp;used&nbsp;to&nbsp;recover&nbsp;from&nbsp;non-fatal<br>
abortable&nbsp;transaction&nbsp;errors&nbsp;when&nbsp;KafkaError.txn_requires_abort()<br>
is&nbsp;True.<br>
&nbsp;<br>
Any&nbsp;outstanding&nbsp;messages&nbsp;will&nbsp;be&nbsp;purged&nbsp;and&nbsp;fail&nbsp;with<br>
_PURGE_INFLIGHT&nbsp;or&nbsp;_PURGE_QUEUE.<br>
&nbsp;<br>
Note:&nbsp;This&nbsp;function&nbsp;will&nbsp;block&nbsp;until&nbsp;all&nbsp;outstanding&nbsp;messages<br>
are&nbsp;purged&nbsp;and&nbsp;the&nbsp;transaction&nbsp;abort&nbsp;request&nbsp;has&nbsp;been<br>
successfully&nbsp;handled&nbsp;by&nbsp;the&nbsp;transaction&nbsp;coordinator,&nbsp;or&nbsp;until<br>
the&nbsp;timeout&nbsp;expires,&nbsp;which&nbsp;ever&nbsp;comes&nbsp;first.&nbsp;On&nbsp;timeout&nbsp;the<br>
application&nbsp;may&nbsp;call&nbsp;the&nbsp;function&nbsp;again.<br>
&nbsp;<br>
Note:&nbsp;Will&nbsp;automatically&nbsp;call&nbsp;<a href="#Producer-purge">purge</a>()&nbsp;and&nbsp;<a href="#Producer-flush">flush</a>()&nbsp;&nbsp;to&nbsp;ensure<br>
all&nbsp;queued&nbsp;and&nbsp;in-flight&nbsp;messages&nbsp;are&nbsp;purged&nbsp;before&nbsp;attempting<br>
to&nbsp;abort&nbsp;the&nbsp;transaction.<br>
&nbsp;<br>
:param&nbsp;float&nbsp;timeout:&nbsp;The&nbsp;maximum&nbsp;amount&nbsp;of&nbsp;time&nbsp;to&nbsp;block<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;waiting&nbsp;for&nbsp;transaction&nbsp;to&nbsp;abort&nbsp;in&nbsp;seconds.<br>
&nbsp;<br>
:raises:&nbsp;KafkaError:&nbsp;Use&nbsp;exc.args[0].retriable()&nbsp;to&nbsp;check&nbsp;if&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;operation&nbsp;may&nbsp;be&nbsp;retried.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Treat&nbsp;any&nbsp;other&nbsp;error&nbsp;as&nbsp;a&nbsp;fatal&nbsp;error.</span></dd></dl>

<dl><dt><a name="Producer-begin_transaction"><strong>begin_transaction</strong></a>(...)</dt><dd><span class="code">..&nbsp;py:function::&nbsp;<a href="#Producer-begin_transaction">begin_transaction</a>()<br>
&nbsp;<br>
Begin&nbsp;a&nbsp;new&nbsp;transaction.<br>
&nbsp;<br>
<a href="#Producer-init_transactions">init_transactions</a>()&nbsp;must&nbsp;have&nbsp;been&nbsp;called&nbsp;successfully&nbsp;(once)<br>
before&nbsp;this&nbsp;function&nbsp;is&nbsp;called.<br>
&nbsp;<br>
Any&nbsp;messages&nbsp;produced&nbsp;or&nbsp;offsets&nbsp;sent&nbsp;to&nbsp;a&nbsp;transaction,&nbsp;after<br>
the&nbsp;successful&nbsp;return&nbsp;of&nbsp;this&nbsp;function&nbsp;will&nbsp;be&nbsp;part&nbsp;of&nbsp;the<br>
transaction&nbsp;and&nbsp;committed&nbsp;or&nbsp;aborted&nbsp;atomically.<br>
&nbsp;<br>
Complete&nbsp;the&nbsp;transaction&nbsp;by&nbsp;calling&nbsp;<a href="#Producer-commit_transaction">commit_transaction</a>()&nbsp;or<br>
Abort&nbsp;the&nbsp;transaction&nbsp;by&nbsp;calling&nbsp;<a href="#Producer-abort_transaction">abort_transaction</a>().<br>
&nbsp;<br>
:raises:&nbsp;KafkaError:&nbsp;Use&nbsp;exc.args[0].retriable()&nbsp;to&nbsp;check&nbsp;if&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;operation&nbsp;may&nbsp;be&nbsp;retried,&nbsp;else&nbsp;treat&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;as&nbsp;a&nbsp;fatal&nbsp;error.</span></dd></dl>

<dl><dt><a name="Producer-commit_transaction"><strong>commit_transaction</strong></a>(...)</dt><dd><span class="code">..&nbsp;py:function::&nbsp;<a href="#Producer-commit_transaction">commit_transaction</a>([timeout])<br>
&nbsp;<br>
Commmit&nbsp;the&nbsp;current&nbsp;transaction.<br>
Any&nbsp;outstanding&nbsp;messages&nbsp;will&nbsp;be&nbsp;flushed&nbsp;(delivered)&nbsp;before<br>
actually&nbsp;committing&nbsp;the&nbsp;transaction.<br>
&nbsp;<br>
If&nbsp;any&nbsp;of&nbsp;the&nbsp;outstanding&nbsp;messages&nbsp;fail&nbsp;permanently&nbsp;the&nbsp;current<br>
transaction&nbsp;will&nbsp;enter&nbsp;the&nbsp;abortable&nbsp;error&nbsp;state&nbsp;and&nbsp;this<br>
function&nbsp;will&nbsp;return&nbsp;an&nbsp;abortable&nbsp;error,&nbsp;in&nbsp;this&nbsp;case&nbsp;the<br>
application&nbsp;must&nbsp;call&nbsp;<a href="#Producer-abort_transaction">abort_transaction</a>()&nbsp;before&nbsp;attempting<br>
a&nbsp;new&nbsp;transaction&nbsp;with&nbsp;<a href="#Producer-begin_transaction">begin_transaction</a>().<br>
&nbsp;<br>
Note:&nbsp;This&nbsp;function&nbsp;will&nbsp;block&nbsp;until&nbsp;all&nbsp;outstanding&nbsp;messages<br>
are&nbsp;delivered&nbsp;and&nbsp;the&nbsp;transaction&nbsp;commit&nbsp;request&nbsp;has&nbsp;been<br>
successfully&nbsp;handled&nbsp;by&nbsp;the&nbsp;transaction&nbsp;coordinator,&nbsp;or&nbsp;until<br>
the&nbsp;timeout&nbsp;expires,&nbsp;which&nbsp;ever&nbsp;comes&nbsp;first.&nbsp;On&nbsp;timeout&nbsp;the<br>
application&nbsp;may&nbsp;call&nbsp;the&nbsp;function&nbsp;again.<br>
&nbsp;<br>
Note:&nbsp;Will&nbsp;automatically&nbsp;call&nbsp;<a href="#Producer-flush">flush</a>()&nbsp;to&nbsp;ensure&nbsp;all&nbsp;queued<br>
messages&nbsp;are&nbsp;delivered&nbsp;before&nbsp;attempting&nbsp;to&nbsp;commit&nbsp;the<br>
transaction.&nbsp;Delivery&nbsp;reports&nbsp;and&nbsp;other&nbsp;callbacks&nbsp;may&nbsp;thus&nbsp;be<br>
triggered&nbsp;from&nbsp;this&nbsp;method.<br>
&nbsp;<br>
:param&nbsp;float&nbsp;timeout:&nbsp;The&nbsp;amount&nbsp;of&nbsp;time&nbsp;to&nbsp;block&nbsp;in&nbsp;seconds.<br>
&nbsp;<br>
:raises:&nbsp;KafkaError:&nbsp;Use&nbsp;exc.args[0].retriable()&nbsp;to&nbsp;check&nbsp;if&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;operation&nbsp;may&nbsp;be&nbsp;retried,&nbsp;or<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exc.args[0].txn_requires_abort()&nbsp;if&nbsp;the&nbsp;current<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transaction&nbsp;has&nbsp;failed&nbsp;and&nbsp;must&nbsp;be&nbsp;aborted&nbsp;by&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Producer-abort_transaction">abort_transaction</a>()&nbsp;and&nbsp;then&nbsp;start&nbsp;a&nbsp;new&nbsp;transaction<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;<a href="#Producer-begin_transaction">begin_transaction</a>().<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Treat&nbsp;any&nbsp;other&nbsp;error&nbsp;as&nbsp;a&nbsp;fatal&nbsp;error.</span></dd></dl>

<dl><dt><a name="Producer-flush"><strong>flush</strong></a>(...)</dt><dd><span class="code">..&nbsp;py:function::&nbsp;<a href="#Producer-flush">flush</a>([timeout])<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;Wait&nbsp;for&nbsp;all&nbsp;messages&nbsp;in&nbsp;the&nbsp;<a href="#Producer">Producer</a>&nbsp;queue&nbsp;to&nbsp;be&nbsp;delivered.<br>
&nbsp;&nbsp;&nbsp;This&nbsp;is&nbsp;a&nbsp;convenience&nbsp;method&nbsp;that&nbsp;calls&nbsp;:py:func:`<a href="#Producer-poll">poll</a>()`&nbsp;until&nbsp;:py:func:`len()`&nbsp;is&nbsp;zero&nbsp;or&nbsp;the&nbsp;optional&nbsp;timeout&nbsp;elapses.<br>
&nbsp;<br>
&nbsp;&nbsp;:param:&nbsp;float&nbsp;timeout:&nbsp;Maximum&nbsp;time&nbsp;to&nbsp;block&nbsp;(requires&nbsp;librdkafka&nbsp;&gt;=&nbsp;v0.9.4).&nbsp;(Seconds)<br>
&nbsp;&nbsp;:returns:&nbsp;Number&nbsp;of&nbsp;messages&nbsp;still&nbsp;in&nbsp;queue.<br>
&nbsp;<br>
..&nbsp;note::&nbsp;See&nbsp;:py:func:`<a href="#Producer-poll">poll</a>()`&nbsp;for&nbsp;a&nbsp;description&nbsp;on&nbsp;what&nbsp;callbacks&nbsp;may&nbsp;be&nbsp;triggered.</span></dd></dl>

<dl><dt><a name="Producer-init_transactions"><strong>init_transactions</strong></a>(...)</dt><dd><span class="code">..&nbsp;py:function:&nbsp;<a href="#Producer-init_transactions">init_transactions</a>([timeout])<br>
&nbsp;<br>
Initializes&nbsp;transactions&nbsp;for&nbsp;the&nbsp;producer&nbsp;instance.<br>
&nbsp;<br>
This&nbsp;function&nbsp;ensures&nbsp;any&nbsp;transactions&nbsp;initiated&nbsp;by&nbsp;previous<br>
instances&nbsp;of&nbsp;the&nbsp;producer&nbsp;with&nbsp;the&nbsp;same&nbsp;`transactional.id`&nbsp;are<br>
completed.<br>
If&nbsp;the&nbsp;previous&nbsp;instance&nbsp;failed&nbsp;with&nbsp;a&nbsp;transaction&nbsp;in&nbsp;progress<br>
the&nbsp;previous&nbsp;transaction&nbsp;will&nbsp;be&nbsp;aborted.<br>
This&nbsp;function&nbsp;needs&nbsp;to&nbsp;be&nbsp;called&nbsp;before&nbsp;any&nbsp;other&nbsp;transactional<br>
or&nbsp;produce&nbsp;functions&nbsp;are&nbsp;called&nbsp;when&nbsp;the&nbsp;`transactional.id`&nbsp;is<br>
configured.<br>
&nbsp;<br>
If&nbsp;the&nbsp;last&nbsp;transaction&nbsp;had&nbsp;begun&nbsp;completion&nbsp;(following<br>
transaction&nbsp;commit)&nbsp;but&nbsp;not&nbsp;yet&nbsp;finished,&nbsp;this&nbsp;function&nbsp;will<br>
await&nbsp;the&nbsp;previous&nbsp;transaction's&nbsp;completion.<br>
&nbsp;<br>
When&nbsp;any&nbsp;previous&nbsp;transactions&nbsp;have&nbsp;been&nbsp;fenced&nbsp;this&nbsp;function<br>
will&nbsp;acquire&nbsp;the&nbsp;internal&nbsp;producer&nbsp;id&nbsp;and&nbsp;epoch,&nbsp;used&nbsp;in&nbsp;all<br>
future&nbsp;transactional&nbsp;messages&nbsp;issued&nbsp;by&nbsp;this&nbsp;producer&nbsp;instance.<br>
&nbsp;<br>
Upon&nbsp;successful&nbsp;return&nbsp;from&nbsp;this&nbsp;function&nbsp;the&nbsp;application&nbsp;has&nbsp;to<br>
perform&nbsp;at&nbsp;least&nbsp;one&nbsp;of&nbsp;the&nbsp;following&nbsp;operations&nbsp;within&nbsp;<br>
`transaction.timeout.ms`&nbsp;to&nbsp;avoid&nbsp;timing&nbsp;out&nbsp;the&nbsp;transaction<br>
on&nbsp;the&nbsp;broker:<br>
*&nbsp;<a href="#Producer-produce">produce</a>()&nbsp;(et.al)<br>
*&nbsp;<a href="#Producer-send_offsets_to_transaction">send_offsets_to_transaction</a>()<br>
*&nbsp;<a href="#Producer-commit_transaction">commit_transaction</a>()<br>
*&nbsp;<a href="#Producer-abort_transaction">abort_transaction</a>()<br>
&nbsp;<br>
:param&nbsp;float&nbsp;timeout:&nbsp;Maximum&nbsp;time&nbsp;to&nbsp;block&nbsp;in&nbsp;seconds.<br>
&nbsp;<br>
:raises:&nbsp;KafkaError:&nbsp;Use&nbsp;exc.args[0].retriable()&nbsp;to&nbsp;check&nbsp;if&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;operation&nbsp;may&nbsp;be&nbsp;retried,&nbsp;else&nbsp;treat&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error&nbsp;as&nbsp;a&nbsp;fatal&nbsp;error.</span></dd></dl>

<dl><dt><a name="Producer-list_topics"><strong>list_topics</strong></a>(...)</dt><dd><span class="code">..&nbsp;py:function::&nbsp;<a href="#Producer-list_topics">list_topics</a>([topic=None],&nbsp;[timeout=-1])<br>
&nbsp;<br>
Request&nbsp;metadata&nbsp;from&nbsp;the&nbsp;cluster.<br>
This&nbsp;method&nbsp;provides&nbsp;the&nbsp;same&nbsp;information&nbsp;as&nbsp;&nbsp;listTopics(),&nbsp;describeTopics()&nbsp;and&nbsp;describeCluster()&nbsp;in&nbsp;&nbsp;the&nbsp;Java&nbsp;Admin&nbsp;client.<br>
&nbsp;<br>
:param&nbsp;str&nbsp;topic:&nbsp;If&nbsp;specified,&nbsp;only&nbsp;request&nbsp;information&nbsp;about&nbsp;this&nbsp;topic,&nbsp;else&nbsp;return&nbsp;results&nbsp;for&nbsp;all&nbsp;topics&nbsp;in&nbsp;cluster.&nbsp;Warning:&nbsp;If&nbsp;auto.create.topics.enable&nbsp;is&nbsp;set&nbsp;to&nbsp;true&nbsp;on&nbsp;the&nbsp;broker&nbsp;and&nbsp;an&nbsp;unknown&nbsp;topic&nbsp;is&nbsp;specified,&nbsp;it&nbsp;will&nbsp;be&nbsp;created.<br>
:param&nbsp;float&nbsp;timeout:&nbsp;The&nbsp;maximum&nbsp;response&nbsp;time&nbsp;before&nbsp;timing&nbsp;out,&nbsp;or&nbsp;-1&nbsp;for&nbsp;infinite&nbsp;timeout.<br>
:rtype:&nbsp;ClusterMetadata<br>
:raises:&nbsp;KafkaException</span></dd></dl>

<dl><dt><a name="Producer-poll"><strong>poll</strong></a>(...)</dt><dd><span class="code">..&nbsp;py:function::&nbsp;<a href="#Producer-poll">poll</a>([timeout])<br>
&nbsp;<br>
Polls&nbsp;the&nbsp;producer&nbsp;for&nbsp;events&nbsp;and&nbsp;calls&nbsp;the&nbsp;corresponding&nbsp;callbacks&nbsp;(if&nbsp;registered).<br>
&nbsp;<br>
Callbacks:<br>
&nbsp;<br>
-&nbsp;``on_delivery``&nbsp;callbacks&nbsp;from&nbsp;:py:func:`<a href="#Producer-produce">produce</a>()`<br>
-&nbsp;...<br>
&nbsp;<br>
:param&nbsp;float&nbsp;timeout:&nbsp;Maximum&nbsp;time&nbsp;to&nbsp;block&nbsp;waiting&nbsp;for&nbsp;events.&nbsp;(Seconds)<br>
:returns:&nbsp;Number&nbsp;of&nbsp;events&nbsp;processed&nbsp;(callbacks&nbsp;served)<br>
:rtype:&nbsp;int</span></dd></dl>

<dl><dt><a name="Producer-produce"><strong>produce</strong></a>(...)</dt><dd><span class="code">..&nbsp;py:function::&nbsp;<a href="#Producer-produce">produce</a>(topic,&nbsp;[value],&nbsp;[key],&nbsp;[partition],&nbsp;[on_delivery],&nbsp;[timestamp],&nbsp;[headers])<br>
&nbsp;<br>
Produce&nbsp;message&nbsp;to&nbsp;topic.<br>
This&nbsp;is&nbsp;an&nbsp;asynchronous&nbsp;operation,&nbsp;an&nbsp;application&nbsp;may&nbsp;use&nbsp;the&nbsp;``callback``&nbsp;(alias&nbsp;``on_delivery``)&nbsp;argument&nbsp;to&nbsp;pass&nbsp;a&nbsp;function&nbsp;(or&nbsp;lambda)&nbsp;that&nbsp;will&nbsp;be&nbsp;called&nbsp;from&nbsp;:py:func:`<a href="#Producer-poll">poll</a>()`&nbsp;when&nbsp;the&nbsp;message&nbsp;has&nbsp;been&nbsp;successfully&nbsp;delivered&nbsp;or&nbsp;permanently&nbsp;fails&nbsp;delivery.<br>
&nbsp;<br>
Currently&nbsp;message&nbsp;headers&nbsp;are&nbsp;not&nbsp;supported&nbsp;on&nbsp;the&nbsp;message&nbsp;returned&nbsp;to&nbsp;the&nbsp;callback.&nbsp;The&nbsp;``msg.headers()``&nbsp;will&nbsp;return&nbsp;None&nbsp;even&nbsp;if&nbsp;the&nbsp;original&nbsp;message&nbsp;had&nbsp;headers&nbsp;set.<br>
&nbsp;<br>
:param&nbsp;str&nbsp;topic:&nbsp;Topic&nbsp;to&nbsp;produce&nbsp;message&nbsp;to<br>
:param&nbsp;str|bytes&nbsp;value:&nbsp;Message&nbsp;payload<br>
:param&nbsp;str|bytes&nbsp;key:&nbsp;Message&nbsp;key<br>
:param&nbsp;int&nbsp;partition:&nbsp;Partition&nbsp;to&nbsp;produce&nbsp;to,&nbsp;else&nbsp;uses&nbsp;the&nbsp;configured&nbsp;built-in&nbsp;partitioner.<br>
:param&nbsp;func&nbsp;on_delivery(err,msg):&nbsp;Delivery&nbsp;report&nbsp;callback&nbsp;to&nbsp;call&nbsp;(from&nbsp;:py:func:`<a href="#Producer-poll">poll</a>()`&nbsp;or&nbsp;:py:func:`<a href="#Producer-flush">flush</a>()`)&nbsp;on&nbsp;successful&nbsp;or&nbsp;failed&nbsp;delivery<br>
:param&nbsp;int&nbsp;timestamp:&nbsp;Message&nbsp;timestamp&nbsp;(CreateTime)&nbsp;in&nbsp;milliseconds&nbsp;since&nbsp;epoch&nbsp;UTC&nbsp;(requires&nbsp;librdkafka&nbsp;&gt;=&nbsp;v0.9.4,&nbsp;api.version.request=true,&nbsp;and&nbsp;broker&nbsp;&gt;=&nbsp;0.10.0.0).&nbsp;Default&nbsp;value&nbsp;is&nbsp;current&nbsp;time.<br>
&nbsp;<br>
:param&nbsp;dict|list&nbsp;headers:&nbsp;Message&nbsp;headers&nbsp;to&nbsp;set&nbsp;on&nbsp;the&nbsp;message.&nbsp;The&nbsp;header&nbsp;key&nbsp;must&nbsp;be&nbsp;a&nbsp;string&nbsp;while&nbsp;the&nbsp;value&nbsp;must&nbsp;be&nbsp;binary,&nbsp;unicode&nbsp;or&nbsp;None.&nbsp;Accepts&nbsp;a&nbsp;list&nbsp;of&nbsp;(key,value)&nbsp;or&nbsp;a&nbsp;dict.&nbsp;(Requires&nbsp;librdkafka&nbsp;&gt;=&nbsp;v0.11.4&nbsp;and&nbsp;broker&nbsp;version&nbsp;&gt;=&nbsp;0.11.0.0)<br>
:rtype:&nbsp;None<br>
:raises&nbsp;BufferError:&nbsp;if&nbsp;the&nbsp;internal&nbsp;producer&nbsp;message&nbsp;queue&nbsp;is&nbsp;full&nbsp;(``queue.buffering.max.messages``&nbsp;exceeded)<br>
:raises&nbsp;KafkaException:&nbsp;for&nbsp;other&nbsp;errors,&nbsp;see&nbsp;exception&nbsp;code<br>
:raises&nbsp;NotImplementedError:&nbsp;if&nbsp;timestamp&nbsp;is&nbsp;specified&nbsp;without&nbsp;underlying&nbsp;library&nbsp;support.</span></dd></dl>

<dl><dt><a name="Producer-purge"><strong>purge</strong></a>(...)</dt><dd><span class="code">..&nbsp;py:function::&nbsp;<a href="#Producer-purge">purge</a>([in_queue=True],&nbsp;[in_flight=True],&nbsp;[blocking=True])<br>
&nbsp;<br>
&nbsp;Purge&nbsp;messages&nbsp;currently&nbsp;handled&nbsp;by&nbsp;the&nbsp;producer&nbsp;instance.<br>
&nbsp;The&nbsp;application&nbsp;will&nbsp;need&nbsp;to&nbsp;call&nbsp;<a href="#Producer-poll">poll</a>()&nbsp;or&nbsp;<a href="#Producer-flush">flush</a>()&nbsp;afterwards&nbsp;to&nbsp;serve&nbsp;the&nbsp;delivery&nbsp;report&nbsp;callbacks&nbsp;of&nbsp;the&nbsp;purged&nbsp;messages.<br>
&nbsp;<br>
:param:&nbsp;bool&nbsp;in_queue:&nbsp;Purge&nbsp;messages&nbsp;from&nbsp;internal&nbsp;queues.&nbsp;By&nbsp;default,&nbsp;true.<br>
:param:&nbsp;bool&nbsp;in_flight:&nbsp;Purge&nbsp;messages&nbsp;in&nbsp;flight&nbsp;to&nbsp;or&nbsp;from&nbsp;the&nbsp;broker.&nbsp;By&nbsp;default,&nbsp;true.<br>
:param:&nbsp;bool&nbsp;blocking:&nbsp;If&nbsp;set&nbsp;to&nbsp;False,&nbsp;will&nbsp;not&nbsp;wait&nbsp;on&nbsp;background&nbsp;thread&nbsp;queue&nbsp;purging&nbsp;to&nbsp;finish.&nbsp;By&nbsp;default,&nbsp;true.</span></dd></dl>

<dl><dt><a name="Producer-send_offsets_to_transaction"><strong>send_offsets_to_transaction</strong></a>(...)</dt><dd><span class="code">..&nbsp;py:function::&nbsp;<a href="#Producer-send_offsets_to_transaction">send_offsets_to_transaction</a>(positions,&nbsp;group_metadata,&nbsp;[timeout])<br>
&nbsp;<br>
Sends&nbsp;a&nbsp;list&nbsp;of&nbsp;topic&nbsp;partition&nbsp;offsets&nbsp;to&nbsp;the&nbsp;consumer&nbsp;group<br>
coordinator&nbsp;for&nbsp;group_metadata&nbsp;and&nbsp;marks&nbsp;the&nbsp;offsets&nbsp;as&nbsp;part<br>
of&nbsp;the&nbsp;current&nbsp;transaction.<br>
These&nbsp;offsets&nbsp;will&nbsp;be&nbsp;considered&nbsp;committed&nbsp;only&nbsp;if&nbsp;the<br>
transaction&nbsp;is&nbsp;committed&nbsp;successfully.<br>
&nbsp;<br>
The&nbsp;offsets&nbsp;should&nbsp;be&nbsp;the&nbsp;next&nbsp;message&nbsp;your&nbsp;application&nbsp;will<br>
consume,&nbsp;i.e.,&nbsp;the&nbsp;last&nbsp;processed&nbsp;message's&nbsp;offset&nbsp;+&nbsp;1&nbsp;for&nbsp;each<br>
partition.<br>
Either&nbsp;track&nbsp;the&nbsp;offsets&nbsp;manually&nbsp;during&nbsp;processing&nbsp;or&nbsp;use<br>
consumer.position()&nbsp;(on&nbsp;the&nbsp;consumer)&nbsp;to&nbsp;get&nbsp;the&nbsp;current&nbsp;offsets<br>
for&nbsp;the&nbsp;partitions&nbsp;assigned&nbsp;to&nbsp;the&nbsp;consumer.<br>
&nbsp;<br>
Use&nbsp;this&nbsp;method&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;a&nbsp;consume-transform-produce&nbsp;loop<br>
prior&nbsp;to&nbsp;committing&nbsp;the&nbsp;transaction&nbsp;with&nbsp;<a href="#Producer-commit_transaction">commit_transaction</a>().<br>
&nbsp;<br>
Note:&nbsp;The&nbsp;consumer&nbsp;must&nbsp;disable&nbsp;auto&nbsp;commits<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(set&nbsp;`enable.auto.commit`&nbsp;to&nbsp;false&nbsp;on&nbsp;the&nbsp;consumer).<br>
&nbsp;<br>
Note:&nbsp;Logical&nbsp;and&nbsp;invalid&nbsp;offsets&nbsp;(e.g.,&nbsp;OFFSET_INVALID)&nbsp;in<br>
offsets&nbsp;will&nbsp;be&nbsp;ignored.&nbsp;If&nbsp;there&nbsp;are&nbsp;no&nbsp;valid&nbsp;offsets&nbsp;in<br>
offsets&nbsp;the&nbsp;function&nbsp;will&nbsp;return&nbsp;successfully&nbsp;and&nbsp;no&nbsp;action<br>
will&nbsp;be&nbsp;taken.<br>
&nbsp;<br>
:param&nbsp;list(TopicPartition)&nbsp;offsets:&nbsp;current&nbsp;consumer/processing<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;position(offsets)&nbsp;for&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list&nbsp;of&nbsp;partitions.<br>
:param&nbsp;<a href="builtins.html#object">object</a>&nbsp;group_metadata:&nbsp;consumer&nbsp;group&nbsp;metadata&nbsp;retrieved<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;the&nbsp;input&nbsp;consumer's<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get_consumer_group_metadata().<br>
:param&nbsp;float&nbsp;timeout:&nbsp;Amount&nbsp;of&nbsp;time&nbsp;to&nbsp;block&nbsp;in&nbsp;seconds.<br>
&nbsp;<br>
:raises:&nbsp;KafkaError:&nbsp;Use&nbsp;exc.args[0].retriable()&nbsp;to&nbsp;check&nbsp;if&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;operation&nbsp;may&nbsp;be&nbsp;retried,&nbsp;or<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exc.args[0].txn_requires_abort()&nbsp;if&nbsp;the&nbsp;current<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transaction&nbsp;has&nbsp;failed&nbsp;and&nbsp;must&nbsp;be&nbsp;aborted&nbsp;by&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Producer-abort_transaction">abort_transaction</a>()&nbsp;and&nbsp;then&nbsp;start&nbsp;a&nbsp;new&nbsp;transaction<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with&nbsp;<a href="#Producer-begin_transaction">begin_transaction</a>().<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Treat&nbsp;any&nbsp;other&nbsp;error&nbsp;as&nbsp;a&nbsp;fatal&nbsp;error.</span></dd></dl>

<dl><dt><a name="Producer-set_sasl_credentials"><strong>set_sasl_credentials</strong></a>(...)</dt><dd><span class="code">..&nbsp;py:function::&nbsp;<a href="#Producer-set_sasl_credentials">set_sasl_credentials</a>(username,&nbsp;password)<br>
&nbsp;<br>
Sets&nbsp;the&nbsp;SASL&nbsp;credentials&nbsp;used&nbsp;for&nbsp;this&nbsp;client.<br>
These&nbsp;credentials&nbsp;will&nbsp;overwrite&nbsp;the&nbsp;old&nbsp;ones,&nbsp;and&nbsp;will&nbsp;be&nbsp;used&nbsp;the&nbsp;next&nbsp;time&nbsp;the&nbsp;client&nbsp;needs&nbsp;to&nbsp;authenticate.<br>
This&nbsp;method&nbsp;will&nbsp;not&nbsp;disconnect&nbsp;existing&nbsp;broker&nbsp;connections&nbsp;that&nbsp;have&nbsp;been&nbsp;established&nbsp;with&nbsp;the&nbsp;old&nbsp;credentials.<br>
This&nbsp;method&nbsp;is&nbsp;applicable&nbsp;only&nbsp;to&nbsp;SASL&nbsp;PLAIN&nbsp;and&nbsp;SCRAM&nbsp;mechanisms.</span></dd></dl>

<hr>
Static methods defined here:<br>
<dl><dt><a name="Producer-__new__"><strong>__new__</strong></a>(*args, **kwargs)</dt><dd><span class="code">Create&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;<a href="builtins.html#object">object</a>.&nbsp;&nbsp;See&nbsp;help(type)&nbsp;for&nbsp;accurate&nbsp;signature.</span></dd></dl>

</td></tr></table></td></tr></table>
</body></html>